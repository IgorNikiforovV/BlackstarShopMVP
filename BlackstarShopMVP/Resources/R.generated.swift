//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try font.validate()
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 2 storyboards.
  struct storyboard {
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `Main`.
    static let main = _R.storyboard.main()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Main", bundle: ...)`
    static func main(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.main)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 1 colors.
  struct color {
    /// Color `AccentColor`.
    static let accentColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AccentColor")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func accentColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.accentColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func accentColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.accentColor.name)
    }
    #endif

    /// This `R.color.colors` struct is generated, and contains static references to 10 colors.
    struct colors {
      /// Color `BlackColor`.
      static let blackColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "Colors/BlackColor")
      /// Color `BlueColor`.
      static let blueColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "Colors/BlueColor")
      /// Color `GrayColor`.
      static let grayColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "Colors/GrayColor")
      /// Color `LightGreyColor`.
      static let lightGreyColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "Colors/LightGreyColor")
      /// Color `PinkColor`.
      static let pinkColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "Colors/PinkColor")
      /// Color `ScarletColor`.
      static let scarletColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "Colors/ScarletColor")
      /// Color `SeparatorColor`.
      static let separatorColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "Colors/SeparatorColor")
      /// Color `SeparatorLineColor`.
      static let separatorLineColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "Colors/SeparatorLineColor")
      /// Color `TurquoiseColor`.
      static let turquoiseColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "Colors/TurquoiseColor")
      /// Color `WhiteColor`.
      static let whiteColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "Colors/WhiteColor")

      #if os(iOS) || os(tvOS)
      /// `UIColor(named: "BlackColor", bundle: ..., traitCollection: ...)`
      @available(tvOS 11.0, *)
      @available(iOS 11.0, *)
      static func blackColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
        return UIKit.UIColor(resource: R.color.colors.blackColor, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIColor(named: "BlueColor", bundle: ..., traitCollection: ...)`
      @available(tvOS 11.0, *)
      @available(iOS 11.0, *)
      static func blueColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
        return UIKit.UIColor(resource: R.color.colors.blueColor, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIColor(named: "GrayColor", bundle: ..., traitCollection: ...)`
      @available(tvOS 11.0, *)
      @available(iOS 11.0, *)
      static func grayColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
        return UIKit.UIColor(resource: R.color.colors.grayColor, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIColor(named: "LightGreyColor", bundle: ..., traitCollection: ...)`
      @available(tvOS 11.0, *)
      @available(iOS 11.0, *)
      static func lightGreyColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
        return UIKit.UIColor(resource: R.color.colors.lightGreyColor, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIColor(named: "PinkColor", bundle: ..., traitCollection: ...)`
      @available(tvOS 11.0, *)
      @available(iOS 11.0, *)
      static func pinkColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
        return UIKit.UIColor(resource: R.color.colors.pinkColor, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIColor(named: "ScarletColor", bundle: ..., traitCollection: ...)`
      @available(tvOS 11.0, *)
      @available(iOS 11.0, *)
      static func scarletColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
        return UIKit.UIColor(resource: R.color.colors.scarletColor, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIColor(named: "SeparatorColor", bundle: ..., traitCollection: ...)`
      @available(tvOS 11.0, *)
      @available(iOS 11.0, *)
      static func separatorColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
        return UIKit.UIColor(resource: R.color.colors.separatorColor, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIColor(named: "SeparatorLineColor", bundle: ..., traitCollection: ...)`
      @available(tvOS 11.0, *)
      @available(iOS 11.0, *)
      static func separatorLineColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
        return UIKit.UIColor(resource: R.color.colors.separatorLineColor, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIColor(named: "TurquoiseColor", bundle: ..., traitCollection: ...)`
      @available(tvOS 11.0, *)
      @available(iOS 11.0, *)
      static func turquoiseColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
        return UIKit.UIColor(resource: R.color.colors.turquoiseColor, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIColor(named: "WhiteColor", bundle: ..., traitCollection: ...)`
      @available(tvOS 11.0, *)
      @available(iOS 11.0, *)
      static func whiteColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
        return UIKit.UIColor(resource: R.color.colors.whiteColor, compatibleWith: traitCollection)
      }
      #endif

      #if os(watchOS)
      /// `UIColor(named: "BlackColor", bundle: ..., traitCollection: ...)`
      @available(watchOSApplicationExtension 4.0, *)
      static func blackColor(_: Void = ()) -> UIKit.UIColor? {
        return UIKit.UIColor(named: R.color.colors.blackColor.name)
      }
      #endif

      #if os(watchOS)
      /// `UIColor(named: "BlueColor", bundle: ..., traitCollection: ...)`
      @available(watchOSApplicationExtension 4.0, *)
      static func blueColor(_: Void = ()) -> UIKit.UIColor? {
        return UIKit.UIColor(named: R.color.colors.blueColor.name)
      }
      #endif

      #if os(watchOS)
      /// `UIColor(named: "GrayColor", bundle: ..., traitCollection: ...)`
      @available(watchOSApplicationExtension 4.0, *)
      static func grayColor(_: Void = ()) -> UIKit.UIColor? {
        return UIKit.UIColor(named: R.color.colors.grayColor.name)
      }
      #endif

      #if os(watchOS)
      /// `UIColor(named: "LightGreyColor", bundle: ..., traitCollection: ...)`
      @available(watchOSApplicationExtension 4.0, *)
      static func lightGreyColor(_: Void = ()) -> UIKit.UIColor? {
        return UIKit.UIColor(named: R.color.colors.lightGreyColor.name)
      }
      #endif

      #if os(watchOS)
      /// `UIColor(named: "PinkColor", bundle: ..., traitCollection: ...)`
      @available(watchOSApplicationExtension 4.0, *)
      static func pinkColor(_: Void = ()) -> UIKit.UIColor? {
        return UIKit.UIColor(named: R.color.colors.pinkColor.name)
      }
      #endif

      #if os(watchOS)
      /// `UIColor(named: "ScarletColor", bundle: ..., traitCollection: ...)`
      @available(watchOSApplicationExtension 4.0, *)
      static func scarletColor(_: Void = ()) -> UIKit.UIColor? {
        return UIKit.UIColor(named: R.color.colors.scarletColor.name)
      }
      #endif

      #if os(watchOS)
      /// `UIColor(named: "SeparatorColor", bundle: ..., traitCollection: ...)`
      @available(watchOSApplicationExtension 4.0, *)
      static func separatorColor(_: Void = ()) -> UIKit.UIColor? {
        return UIKit.UIColor(named: R.color.colors.separatorColor.name)
      }
      #endif

      #if os(watchOS)
      /// `UIColor(named: "SeparatorLineColor", bundle: ..., traitCollection: ...)`
      @available(watchOSApplicationExtension 4.0, *)
      static func separatorLineColor(_: Void = ()) -> UIKit.UIColor? {
        return UIKit.UIColor(named: R.color.colors.separatorLineColor.name)
      }
      #endif

      #if os(watchOS)
      /// `UIColor(named: "TurquoiseColor", bundle: ..., traitCollection: ...)`
      @available(watchOSApplicationExtension 4.0, *)
      static func turquoiseColor(_: Void = ()) -> UIKit.UIColor? {
        return UIKit.UIColor(named: R.color.colors.turquoiseColor.name)
      }
      #endif

      #if os(watchOS)
      /// `UIColor(named: "WhiteColor", bundle: ..., traitCollection: ...)`
      @available(watchOSApplicationExtension 4.0, *)
      static func whiteColor(_: Void = ()) -> UIKit.UIColor? {
        return UIKit.UIColor(named: R.color.colors.whiteColor.name)
      }
      #endif

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.file` struct is generated, and contains static references to 7 files.
  struct file {
    /// Resource file `SF-Pro-Display-Bold.otf`.
    static let sfProDisplayBoldOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "SF-Pro-Display-Bold", pathExtension: "otf")
    /// Resource file `SF-Pro-Display-Medium.otf`.
    static let sfProDisplayMediumOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "SF-Pro-Display-Medium", pathExtension: "otf")
    /// Resource file `SF-Pro-Display-Regular.otf`.
    static let sfProDisplayRegularOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "SF-Pro-Display-Regular", pathExtension: "otf")
    /// Resource file `SF-Pro-Display-Semibold.otf`.
    static let sfProDisplaySemiboldOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "SF-Pro-Display-Semibold", pathExtension: "otf")
    /// Resource file `SF-Pro-Text-Light.otf`.
    static let sfProTextLightOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "SF-Pro-Text-Light", pathExtension: "otf")
    /// Resource file `SF-Pro-Text-Regular.otf`.
    static let sfProTextRegularOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "SF-Pro-Text-Regular", pathExtension: "otf")
    /// Resource file `SF-Pro-Text-Semibold.otf`.
    static let sfProTextSemiboldOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "SF-Pro-Text-Semibold", pathExtension: "otf")

    /// `bundle.url(forResource: "SF-Pro-Display-Bold", withExtension: "otf")`
    static func sfProDisplayBoldOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.sfProDisplayBoldOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "SF-Pro-Display-Medium", withExtension: "otf")`
    static func sfProDisplayMediumOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.sfProDisplayMediumOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "SF-Pro-Display-Regular", withExtension: "otf")`
    static func sfProDisplayRegularOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.sfProDisplayRegularOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "SF-Pro-Display-Semibold", withExtension: "otf")`
    static func sfProDisplaySemiboldOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.sfProDisplaySemiboldOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "SF-Pro-Text-Light", withExtension: "otf")`
    static func sfProTextLightOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.sfProTextLightOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "SF-Pro-Text-Regular", withExtension: "otf")`
    static func sfProTextRegularOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.sfProTextRegularOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "SF-Pro-Text-Semibold", withExtension: "otf")`
    static func sfProTextSemiboldOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.sfProTextSemiboldOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.font` struct is generated, and contains static references to 7 fonts.
  struct font: Rswift.Validatable {
    /// Font `SFProDisplay-Bold`.
    static let sfProDisplayBold = Rswift.FontResource(fontName: "SFProDisplay-Bold")
    /// Font `SFProDisplay-Medium`.
    static let sfProDisplayMedium = Rswift.FontResource(fontName: "SFProDisplay-Medium")
    /// Font `SFProDisplay-Regular`.
    static let sfProDisplayRegular = Rswift.FontResource(fontName: "SFProDisplay-Regular")
    /// Font `SFProDisplay-Semibold`.
    static let sfProDisplaySemibold = Rswift.FontResource(fontName: "SFProDisplay-Semibold")
    /// Font `SFProText-Light`.
    static let sfProTextLight = Rswift.FontResource(fontName: "SFProText-Light")
    /// Font `SFProText-Regular`.
    static let sfProTextRegular = Rswift.FontResource(fontName: "SFProText-Regular")
    /// Font `SFProText-Semibold`.
    static let sfProTextSemibold = Rswift.FontResource(fontName: "SFProText-Semibold")

    /// `UIFont(name: "SFProDisplay-Bold", size: ...)`
    static func sfProDisplayBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: sfProDisplayBold, size: size)
    }

    /// `UIFont(name: "SFProDisplay-Medium", size: ...)`
    static func sfProDisplayMedium(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: sfProDisplayMedium, size: size)
    }

    /// `UIFont(name: "SFProDisplay-Regular", size: ...)`
    static func sfProDisplayRegular(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: sfProDisplayRegular, size: size)
    }

    /// `UIFont(name: "SFProDisplay-Semibold", size: ...)`
    static func sfProDisplaySemibold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: sfProDisplaySemibold, size: size)
    }

    /// `UIFont(name: "SFProText-Light", size: ...)`
    static func sfProTextLight(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: sfProTextLight, size: size)
    }

    /// `UIFont(name: "SFProText-Regular", size: ...)`
    static func sfProTextRegular(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: sfProTextRegular, size: size)
    }

    /// `UIFont(name: "SFProText-Semibold", size: ...)`
    static func sfProTextSemibold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: sfProTextSemibold, size: size)
    }

    static func validate() throws {
      if R.font.sfProDisplayBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'SFProDisplay-Bold' could not be loaded, is 'SF-Pro-Display-Bold.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.sfProDisplayMedium(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'SFProDisplay-Medium' could not be loaded, is 'SF-Pro-Display-Medium.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.sfProDisplayRegular(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'SFProDisplay-Regular' could not be loaded, is 'SF-Pro-Display-Regular.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.sfProDisplaySemibold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'SFProDisplay-Semibold' could not be loaded, is 'SF-Pro-Display-Semibold.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.sfProTextLight(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'SFProText-Light' could not be loaded, is 'SF-Pro-Text-Light.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.sfProTextRegular(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'SFProText-Regular' could not be loaded, is 'SF-Pro-Text-Regular.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.sfProTextSemibold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'SFProText-Semibold' could not be loaded, is 'SF-Pro-Text-Semibold.otf' added to the UIAppFonts array in this targets Info.plist?") }
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 0 images.
  struct image {
    /// This `R.image.basket` struct is generated, and contains static references to 2 images.
    struct basket {
      /// Image `BasketIcon`.
      static let basketIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "Basket/BasketIcon")
      /// Image `DeleteAll`.
      static let deleteAll = Rswift.ImageResource(bundle: R.hostingBundle, name: "Basket/DeleteAll")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "BasketIcon", bundle: ..., traitCollection: ...)`
      static func basketIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.basket.basketIcon, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "DeleteAll", bundle: ..., traitCollection: ...)`
      static func deleteAll(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.basket.deleteAll, compatibleWith: traitCollection)
      }
      #endif

      fileprivate init() {}
    }

    /// This `R.image.categoryCell` struct is generated, and contains static references to 1 images.
    struct categoryCell {
      /// Image `Placeholder`.
      static let placeholder = Rswift.ImageResource(bundle: R.hostingBundle, name: "CategoryCell/Placeholder")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Placeholder", bundle: ..., traitCollection: ...)`
      static func placeholder(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.categoryCell.placeholder, compatibleWith: traitCollection)
      }
      #endif

      fileprivate init() {}
    }

    /// This `R.image.common` struct is generated, and contains static references to 3 images.
    struct common {
      /// Image `CheckMark`.
      static let checkMark = Rswift.ImageResource(bundle: R.hostingBundle, name: "Common/CheckMark")
      /// Image `measure`.
      static let measure = Rswift.ImageResource(bundle: R.hostingBundle, name: "Common/measure")
      /// Image `placeholder`.
      static let placeholder = Rswift.ImageResource(bundle: R.hostingBundle, name: "Common/placeholder")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "CheckMark", bundle: ..., traitCollection: ...)`
      static func checkMark(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.common.checkMark, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "measure", bundle: ..., traitCollection: ...)`
      static func measure(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.common.measure, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "placeholder", bundle: ..., traitCollection: ...)`
      static func placeholder(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.common.placeholder, compatibleWith: traitCollection)
      }
      #endif

      fileprivate init() {}
    }

    /// This `R.image.launch` struct is generated, and contains static references to 1 images.
    struct launch {
      /// Image `Brand`.
      static let brand = Rswift.ImageResource(bundle: R.hostingBundle, name: "Launch/Brand")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Brand", bundle: ..., traitCollection: ...)`
      static func brand(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.launch.brand, compatibleWith: traitCollection)
      }
      #endif

      fileprivate init() {}
    }

    /// This `R.image.product` struct is generated, and contains static references to 2 images.
    struct product {
      /// Image `BackButton`.
      static let backButton = Rswift.ImageResource(bundle: R.hostingBundle, name: "Product/BackButton")
      /// Image `Basket`.
      static let basket = Rswift.ImageResource(bundle: R.hostingBundle, name: "Product/Basket")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "BackButton", bundle: ..., traitCollection: ...)`
      static func backButton(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.product.backButton, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Basket", bundle: ..., traitCollection: ...)`
      static func basket(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.product.basket, compatibleWith: traitCollection)
      }
      #endif

      fileprivate init() {}
    }

    /// This `R.image.tabBarIcons` struct is generated, and contains static references to 2 images.
    struct tabBarIcons {
      /// Image `Basket`.
      static let basket = Rswift.ImageResource(bundle: R.hostingBundle, name: "TabBarIcons/Basket")
      /// Image `Search`.
      static let search = Rswift.ImageResource(bundle: R.hostingBundle, name: "TabBarIcons/Search")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Basket", bundle: ..., traitCollection: ...)`
      static func basket(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tabBarIcons.basket, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Search", bundle: ..., traitCollection: ...)`
      static func search(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tabBarIcons.search, compatibleWith: traitCollection)
      }
      #endif

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.info` struct is generated, and contains static references to 1 properties.
  struct info {
    struct uiApplicationSceneManifest {
      static let _key = "UIApplicationSceneManifest"
      static let uiApplicationSupportsMultipleScenes = false

      struct uiSceneConfigurations {
        static let _key = "UISceneConfigurations"

        struct uiWindowSceneSessionRoleApplication {
          struct defaultConfiguration {
            static let _key = "Default Configuration"
            static let uiSceneConfigurationName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneConfigurationName") ?? "Default Configuration"
            static let uiSceneDelegateClassName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneDelegateClassName") ?? "$(PRODUCT_MODULE_NAME).SceneDelegate"
            static let uiSceneStoryboardFile = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneStoryboardFile") ?? "Main"

            fileprivate init() {}
          }

          fileprivate init() {}
        }

        fileprivate init() {}
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 13 nibs.
  struct nib {
    /// Nib ` ImageHorizontalCollectionView`.
    static let imageHorizontalCollectionView = _R.nib._ImageHorizontalCollectionView()
    /// Nib `ActionSheetCell`.
    static let actionSheetCell = _R.nib._ActionSheetCell()
    /// Nib `ActionSheetHeaderView`.
    static let actionSheetHeaderView = _R.nib._ActionSheetHeaderView()
    /// Nib `AlertView`.
    static let alertView = _R.nib._AlertView()
    /// Nib `BasketCell`.
    static let basketCell = _R.nib._BasketCell()
    /// Nib `BasketSceneViewController`.
    static let basketSceneViewController = _R.nib._BasketSceneViewController()
    /// Nib `CategoryCell`.
    static let categoryCell = _R.nib._CategoryCell()
    /// Nib `CategorySceneViewController`.
    static let categorySceneViewController = _R.nib._CategorySceneViewController()
    /// Nib `ImageHorizontalCollectionCell`.
    static let imageHorizontalCollectionCell = _R.nib._ImageHorizontalCollectionCell()
    /// Nib `ProductCell`.
    static let productCell = _R.nib._ProductCell()
    /// Nib `ProductListSceneViewController`.
    static let productListSceneViewController = _R.nib._ProductListSceneViewController()
    /// Nib `ProductSceneViewController`.
    static let productSceneViewController = _R.nib._ProductSceneViewController()
    /// Nib `ShadowActionSheetController`.
    static let shadowActionSheetController = _R.nib._ShadowActionSheetController()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: " ImageHorizontalCollectionView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.imageHorizontalCollectionView) instead")
    static func imageHorizontalCollectionView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.imageHorizontalCollectionView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ActionSheetCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.actionSheetCell) instead")
    static func actionSheetCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.actionSheetCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ActionSheetHeaderView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.actionSheetHeaderView) instead")
    static func actionSheetHeaderView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.actionSheetHeaderView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AlertView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.alertView) instead")
    static func alertView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.alertView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "BasketCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.basketCell) instead")
    static func basketCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.basketCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "BasketSceneViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.basketSceneViewController) instead")
    static func basketSceneViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.basketSceneViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CategoryCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.categoryCell) instead")
    static func categoryCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.categoryCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "CategorySceneViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.categorySceneViewController) instead")
    static func categorySceneViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.categorySceneViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ImageHorizontalCollectionCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.imageHorizontalCollectionCell) instead")
    static func imageHorizontalCollectionCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.imageHorizontalCollectionCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ProductCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.productCell) instead")
    static func productCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.productCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ProductListSceneViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.productListSceneViewController) instead")
    static func productListSceneViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.productListSceneViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ProductSceneViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.productSceneViewController) instead")
    static func productSceneViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.productSceneViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ShadowActionSheetController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.shadowActionSheetController) instead")
    static func shadowActionSheetController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.shadowActionSheetController)
    }
    #endif

    static func actionSheetCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ActionSheetCell? {
      return R.nib.actionSheetCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ActionSheetCell
    }

    static func actionSheetHeaderView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.actionSheetHeaderView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func alertView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.alertView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func basketCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> BasketCell? {
      return R.nib.basketCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? BasketCell
    }

    static func basketSceneViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.basketSceneViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func categoryCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CategoryCell? {
      return R.nib.categoryCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CategoryCell
    }

    static func categorySceneViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.categorySceneViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func imageHorizontalCollectionCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ImageHorizontalCollectionCell? {
      return R.nib.imageHorizontalCollectionCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ImageHorizontalCollectionCell
    }

    static func imageHorizontalCollectionView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.imageHorizontalCollectionView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func productCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ProductCell? {
      return R.nib.productCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ProductCell
    }

    static func productListSceneViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.productListSceneViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func productSceneViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.productSceneViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func shadowActionSheetController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.shadowActionSheetController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 5 reuse identifiers.
  struct reuseIdentifier {
    /// Reuse identifier `ActionSheetCell`.
    static let actionSheetCell: Rswift.ReuseIdentifier<ActionSheetCell> = Rswift.ReuseIdentifier(identifier: "ActionSheetCell")
    /// Reuse identifier `BasketCell`.
    static let basketCell: Rswift.ReuseIdentifier<BasketCell> = Rswift.ReuseIdentifier(identifier: "BasketCell")
    /// Reuse identifier `CategoryCell`.
    static let categoryCell: Rswift.ReuseIdentifier<CategoryCell> = Rswift.ReuseIdentifier(identifier: "CategoryCell")
    /// Reuse identifier `ImageHorizontalCollectionCell`.
    static let imageHorizontalCollectionCell: Rswift.ReuseIdentifier<ImageHorizontalCollectionCell> = Rswift.ReuseIdentifier(identifier: "ImageHorizontalCollectionCell")
    /// Reuse identifier `ProductCell`.
    static let productCell: Rswift.ReuseIdentifier<ProductCell> = Rswift.ReuseIdentifier(identifier: "ProductCell")

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 1 localization tables.
  struct string {
    /// This `R.string.localizable` struct is generated, and contains static references to 16 localization keys.
    struct localizable {
      /// Value: %@ ₽
      static let productCellPriceTitle = Rswift.StringResource(key: "Product.cell.price.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Выберите подходящий размер
      static let productAlertSizeTitle = Rswift.StringResource(key: "Product.alert.size.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: ДА
      static let basketDeleteOkButtonTitle = Rswift.StringResource(key: "Basket.delete.ok.button.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: ДОБАВИТЬ В КОРЗИНУ
      static let productAddBasketTitle = Rswift.StringResource(key: "Product.addBasket.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Итого:
      static let basketTotalTitle = Rswift.StringResource(key: "Basket.total.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Купить
      static let productCellPayTitle = Rswift.StringResource(key: "Product.cell.pay.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: НЕТ
      static let basketDeleteCancelButtonTitle = Rswift.StringResource(key: "Basket.delete.cancel.button.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: На главную
      static let basketPlaceOrderTitleEmpty = Rswift.StringResource(key: "Basket.place.order.title.empty", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Оформить заказ
      static let basketPlaceOrderTitle = Rswift.StringResource(key: "Basket.place.order.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Продукты по выбранной подкатегории отсутствуют
      static let productNoDataTitle = Rswift.StringResource(key: "Product.no.data.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Размер: %@
      static let basketProductSize = Rswift.StringResource(key: "Basket.product.size", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Стоимость:
      static let productPriceTitle = Rswift.StringResource(key: "Product.price.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Удалить весь товар из корзины?
      static let basketDeleteAllTitle = Rswift.StringResource(key: "Basket.delete.all.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Удалить товар из корзины?
      static let basketDeleteOneTitle = Rswift.StringResource(key: "Basket.delete.one.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Цвет: %@
      static let basketProductColor = Rswift.StringResource(key: "Basket.product.color", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: не задан
      static let basketProductNoSizeTitle = Rswift.StringResource(key: "Basket.product.no.size.title", tableName: "Localizable", bundle: R.hostingBundle, locales: [], comment: nil)

      /// Value: %@ ₽
      static func productCellPriceTitle(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Product.cell.price.title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Product.cell.price.title"
        }

        let format = NSLocalizedString("Product.cell.price.title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// Value: Выберите подходящий размер
      static func productAlertSizeTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Product.alert.size.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Product.alert.size.title"
        }

        return NSLocalizedString("Product.alert.size.title", bundle: bundle, comment: "")
      }

      /// Value: ДА
      static func basketDeleteOkButtonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Basket.delete.ok.button.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Basket.delete.ok.button.title"
        }

        return NSLocalizedString("Basket.delete.ok.button.title", bundle: bundle, comment: "")
      }

      /// Value: ДОБАВИТЬ В КОРЗИНУ
      static func productAddBasketTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Product.addBasket.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Product.addBasket.title"
        }

        return NSLocalizedString("Product.addBasket.title", bundle: bundle, comment: "")
      }

      /// Value: Итого:
      static func basketTotalTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Basket.total.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Basket.total.title"
        }

        return NSLocalizedString("Basket.total.title", bundle: bundle, comment: "")
      }

      /// Value: Купить
      static func productCellPayTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Product.cell.pay.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Product.cell.pay.title"
        }

        return NSLocalizedString("Product.cell.pay.title", bundle: bundle, comment: "")
      }

      /// Value: НЕТ
      static func basketDeleteCancelButtonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Basket.delete.cancel.button.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Basket.delete.cancel.button.title"
        }

        return NSLocalizedString("Basket.delete.cancel.button.title", bundle: bundle, comment: "")
      }

      /// Value: На главную
      static func basketPlaceOrderTitleEmpty(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Basket.place.order.title.empty", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Basket.place.order.title.empty"
        }

        return NSLocalizedString("Basket.place.order.title.empty", bundle: bundle, comment: "")
      }

      /// Value: Оформить заказ
      static func basketPlaceOrderTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Basket.place.order.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Basket.place.order.title"
        }

        return NSLocalizedString("Basket.place.order.title", bundle: bundle, comment: "")
      }

      /// Value: Продукты по выбранной подкатегории отсутствуют
      static func productNoDataTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Product.no.data.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Product.no.data.title"
        }

        return NSLocalizedString("Product.no.data.title", bundle: bundle, comment: "")
      }

      /// Value: Размер: %@
      static func basketProductSize(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Basket.product.size", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Basket.product.size"
        }

        let format = NSLocalizedString("Basket.product.size", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// Value: Стоимость:
      static func productPriceTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Product.price.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Product.price.title"
        }

        return NSLocalizedString("Product.price.title", bundle: bundle, comment: "")
      }

      /// Value: Удалить весь товар из корзины?
      static func basketDeleteAllTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Basket.delete.all.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Basket.delete.all.title"
        }

        return NSLocalizedString("Basket.delete.all.title", bundle: bundle, comment: "")
      }

      /// Value: Удалить товар из корзины?
      static func basketDeleteOneTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Basket.delete.one.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Basket.delete.one.title"
        }

        return NSLocalizedString("Basket.delete.one.title", bundle: bundle, comment: "")
      }

      /// Value: Цвет: %@
      static func basketProductColor(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("Basket.product.color", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Basket.product.color"
        }

        let format = NSLocalizedString("Basket.product.color", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// Value: не задан
      static func basketProductNoSizeTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Basket.product.no.size.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "Basket.product.no.size.title"
        }

        return NSLocalizedString("Basket.product.no.size.title", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib {
    struct _ActionSheetCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = ActionSheetCell

      let bundle = R.hostingBundle
      let identifier = "ActionSheetCell"
      let name = "ActionSheetCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ActionSheetCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ActionSheetCell
      }

      fileprivate init() {}
    }

    struct _ActionSheetHeaderView: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "ActionSheetHeaderView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _AlertView: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "AlertView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _BasketCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = BasketCell

      let bundle = R.hostingBundle
      let identifier = "BasketCell"
      let name = "BasketCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> BasketCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? BasketCell
      }

      fileprivate init() {}
    }

    struct _BasketSceneViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "BasketSceneViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _CategoryCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = CategoryCell

      let bundle = R.hostingBundle
      let identifier = "CategoryCell"
      let name = "CategoryCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> CategoryCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? CategoryCell
      }

      fileprivate init() {}
    }

    struct _CategorySceneViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "CategorySceneViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _ImageHorizontalCollectionCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = ImageHorizontalCollectionCell

      let bundle = R.hostingBundle
      let identifier = "ImageHorizontalCollectionCell"
      let name = "ImageHorizontalCollectionCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ImageHorizontalCollectionCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ImageHorizontalCollectionCell
      }

      fileprivate init() {}
    }

    struct _ImageHorizontalCollectionView: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = " ImageHorizontalCollectionView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _ProductCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = ProductCell

      let bundle = R.hostingBundle
      let identifier = "ProductCell"
      let name = "ProductCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> ProductCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? ProductCell
      }

      fileprivate init() {}
    }

    struct _ProductListSceneViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "ProductListSceneViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _ProductSceneViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "ProductSceneViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _ShadowActionSheetController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "ShadowActionSheetController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try main.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if UIKit.UIImage(named: "Launch/Brand", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'Launch/Brand' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct main: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = ViewController

      let bundle = R.hostingBundle
      let name = "Main"

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
